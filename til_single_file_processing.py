# -*- coding: utf-8 -*-
"""TIL_single_file_processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NgCgsKTnMCRSg0ZsA6TApW-InlF9cmxv
"""

#LIBRARIES
import pandas as pd 
import glob 
import os

"""Adding **Label**"""

h_til="/content/drive/MyDrive/HNSCC/single_file_processing/til_healthy_train/combined.csv"
h_til = pd.read_csv(h_til)
h_til_l = h_til.assign(label='0')
h_til_l = pd.DataFrame(h_til_l)
h_til_l.drop(h_til_l.iloc[:, 0:2], inplace=True, axis=1)
h_til_l=h_til_l.fillna(0)
h_til_l.to_csv("/content/drive/MyDrive/HNSCC/single_file_processing/Labelled data/til_healthy_train_0")

h_til_l=pd.read_csv('/content/drive/MyDrive/HNSCC/single_file_processing/Labelled data/til_healthy_train_0')
h_til_l

#Disease til (HPV+ and HPV-)
hp="/content/drive/MyDrive/HNSCC/single_file_processing/til_disease_pos_train/combined.csv"
hp = pd.read_csv(hp)
hn="/content/drive/MyDrive/HNSCC/single_file_processing/til_disease_neg_train/combined.csv"
hn = pd.read_csv(hn)

d_til= pd.DataFrame()
d_til= pd.concat((hp,hn),axis =0)
#d_til = pd.read_csv(d_til)
d_til_l = d_til.assign(label='1')
d_til_l = pd.DataFrame(d_til_l)
d_til_l.drop(d_til_l.iloc[:, 0:2], inplace=True, axis=1)
d_til_l=d_til_l.fillna(0)
d_til_l.to_csv("/content/drive/MyDrive/HNSCC/single_file_processing/Labelled data/til_disease_both_train_1")

d_til_l=pd.read_csv('/content/drive/MyDrive/HNSCC/single_file_processing/Labelled data/til_disease_both_train_1')
d_til_l

"""Merge both disease and healthy"""

d_til_l

h_til_l

til_l=pd.concat((d_til_l,h_til_l),axis =0)
til_l

til_l=til_l.fillna(0)
til_l.drop(til_l.iloc[:, 0:1], inplace=True, axis=1)

til_l.to_csv("/content/drive/MyDrive/HNSCC/single_file_processing/Labelled data/til_Both_d_h_Train_Labelled.csv")

til_l=pd.read_csv('/content/drive/MyDrive/HNSCC/single_file_processing/Labelled data/til_Both_d_h_Train_Labelled.csv')

til_l

til_l.drop(til_l.iloc[:, 0:1], inplace=True, axis=1)
til_l

"""Removing genes again more than 80% """

til_l=til_l.loc[:,(til_l==0).mean()<.80]
til_l

"""Remove fisrt column and label"""

til_label=til_l.iloc[:,1:]     #without sample column

til_wo_label = til_label.iloc[: , :-1]  #without label

"""PymRMR"""

!pip install mrmr_selection
import mrmr

from mrmr import mrmr_classif

selected_features = mrmr_classif(X=til_wo_label, y=til_label['label'], K=100)

selected_features

X_selected = til_wo_label[selected_features]
X_selected

# split a dataset into train and test sets

from sklearn.model_selection import train_test_split
# create dataset
# split into train test sets
Y=til_label['label']
X_train, X_test, y_train, y_test = train_test_split(X_selected, Y, test_size=0.20)
print(X_train.shape, X_test.shape, y_train.shape, y_test.shape)



import tensorflow as tf
from tensorflow import keras

model = keras.Sequential([
    keras.layers.Flatten(input_shape=(100,)),
    keras.layers.Dense(16, activation=tf.nn.relu),
	keras.layers.Dense(16, activation=tf.nn.relu),
    keras.layers.Dense(1, activation=tf.nn.sigmoid),
])

y_train=y_train.astype(int)
X_train=X_train.astype(int)
y_test=y_test.astype(int)
X_test=X_test.astype(int)

model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

model.fit(X_train, y_train, epochs=50, batch_size=32)
test_loss, test_acc = model.evaluate(X_test, y_test)
train_loss, train_acc=model.evaluate(X_train, y_train)

test_loss

test_acc

train_loss

train_acc



pred=model.predict(X_test)
pred=pred.round()
pred

from sklearn.metrics import confusion_matrix
#import scikitplot as skplt
y_true=y_test
y_pred=pred
cm1=confusion_matrix(y_true=y_test, y_pred=pred)
print(cm1)
#skplt.metrics.plot_confusion_mXtrix(real_values, pred_values,figsize=(8,8))

TP=cm1[0,0]
FN=cm1[0,1]
TN=cm1[1,1]
FP=cm1[1,0]

import math
sensitivity1 = TP / (TP + FN)
print('Sensitivity : ', sensitivity1 )

specificity1 = TN / (FP + TN)
print('Specificity : ', specificity1)
precision= TP / (TP + FP)
print('Precision : ', precision)
NegativePredictiveValue= TN / (TN + FN)
print('Negative Predictive Value : ', NegativePredictiveValue)
FalsePositiveRate=  FP / (FP + TN)
print('False Positive Rate : ', FalsePositiveRate)
FDR= FP / (FP + TP)
print('False Discovery Rate : ', FDR)
FNR= FN / (FN + TP)
print('False Negative Rate : ', FNR)
#Accuracy= (TP + TN) / (P + N)
#print('Accuracy : ', Accuracy)
F1_Score= (2*TP) / ((2*TP) + FP + FN)
print('F1 Score : ', F1_Score)
MCC=(TP*TN - FP*FN) / math.sqrt((TP+FP)*(TP+FN)*(TN+FP)*(TN+FN))
print('Matthews Correlation Coefficient :', MCC)

from sklearn.metrics import f1_score
f1_score(y_true, y_pred)

from sklearn.metrics import recall_score
recall_score(y_test, pred)

from sklearn.metrics import matthews_corrcoef
matthews_corrcoef(y_test, pred)

from sklearn.metrics import accuracy_score
accuracy_score(y_test, pred)



import sklearn.metrics as metrics
# calculate the fpr and tpr for all thresholds of the classification

fpr, tpr, threshold = metrics.roc_curve(y_test, pred)
roc_auc = metrics.auc(fpr, tpr)

!pip install matplotlib.pyplot
import matplotlib.pyplot as plt
plt.title('Receiver Operating Characteristic')
plt.plot(fpr, tpr, 'b', label = 'AUC = %0.2f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1],'r--')
plt.xlim([0, 1])
plt.ylim([0, 1])
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()

"""### *HPV+ and HPV- *"""

#LIBRARIES
import pandas as pd 
import glob 
import os

#Disease til (HPV+ and HPV-)
hp="/content/drive/MyDrive/HNSCC/single_file_processing/til_disease_pos_train/combined.csv"
hp = pd.read_csv(hp)
hn="/content/drive/MyDrive/HNSCC/single_file_processing/til_disease_neg_train/combined.csv"
hn = pd.read_csv(hn)

hp

hn

hp_til_l = hp.assign(label='1')
hp_til_l = pd.DataFrame(hp_til_l)
hp_til_l.drop(hp_til_l.iloc[:, 0:2], inplace=True, axis=1)
hp_til_l=hp_til_l.fillna(0)
hp_til_l.to_csv("/content/drive/MyDrive/HNSCC/single_file_processing/Labelled data/til_HPV_pos_label_1")

hp_til_l

hn_til_l = hn.assign(label='0')
hn_til_l = pd.DataFrame(hn_til_l)
hn_til_l.drop(hn_til_l.iloc[:, 0:2], inplace=True, axis=1)
hn_til_l=hn_til_l.fillna(0)
hn_til_l.to_csv("/content/drive/MyDrive/HNSCC/single_file_processing/Labelled data/til_HPV_neg_label_1")

hn_til_l

til_l= pd.concat((hp_til_l,hn_til_l),axis =0)
til_l=til_l.fillna(0)
til_l.to_csv("/content/drive/MyDrive/HNSCC/single_file_processing/Labelled data/til_both_label")

til_l



til_l=til_l.loc[:,(til_l==0).mean()<.80]
til_l

til_label=til_l.iloc[:,1:]     #without sample column

til_wo_label = til_label.iloc[: , :-1]  #without label

!pip install mrmr_selection
import mrmr

from mrmr import mrmr_classif

selected_features = mrmr_classif(X=til_wo_label, y=til_label['label'], K=100)

selected_features

X_selected = til_wo_label[selected_features]
X_selected

# split a dataset into train and test sets

from sklearn.model_selection import train_test_split
# create dataset
# split into train test sets
Y=til_label['label']
X_train, X_test, y_train, y_test = train_test_split(X_selected, Y, test_size=0.20)
print(X_train.shape, X_test.shape, y_train.shape, y_test.shape)

import tensorflow as tf
from tensorflow import keras

model = keras.Sequential([
    keras.layers.Flatten(input_shape=(100,)),
    keras.layers.Dense(16, activation=tf.nn.relu),
	keras.layers.Dense(16, activation=tf.nn.relu),
    keras.layers.Dense(1, activation=tf.nn.sigmoid),
])

y_train=y_train.astype(int)
X_train=X_train.astype(int)
y_test=y_test.astype(int)
X_test=X_test.astype(int)

model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

model.fit(X_train, y_train, epochs=50, batch_size=32)
test_loss, test_acc = model.evaluate(X_test, y_test)
train_loss, train_acc=model.evaluate(X_train, y_train)

test_loss

test_acc

train_loss

train_acc



pred=model.predict(X_test)
pred=pred.round()
pred

from sklearn.metrics import confusion_matrix
#import scikitplot as skplt
y_true=y_test
y_pred=pred
cm1=confusion_matrix(y_true=y_test, y_pred=pred)
print(cm1)
#skplt.metrics.plot_confusion_mXtrix(real_values, pred_values,figsize=(8,8))

TP=cm1[0,0]
FN=cm1[0,1]
TN=cm1[1,1]
FP=cm1[1,0]

import math
sensitivity1 = TP / (TP + FN)
print('Sensitivity : ', sensitivity1 )

specificity1 = TN / (FP + TN)
print('Specificity : ', specificity1)
precision= TP / (TP + FP)
print('Precision : ', precision)
NegativePredictiveValue= TN / (TN + FN)
print('Negative Predictive Value : ', NegativePredictiveValue)
FalsePositiveRate=  FP / (FP + TN)
print('False Positive Rate : ', FalsePositiveRate)
FDR= FP / (FP + TP)
print('False Discovery Rate : ', FDR)
FNR= FN / (FN + TP)
print('False Negative Rate : ', FNR)
#Accuracy= (TP + TN) / (P + N)
#print('Accuracy : ', Accuracy)
F1_Score= (2*TP) / ((2*TP) + FP + FN)
print('F1 Score : ', F1_Score)
MCC=(TP*TN - FP*FN) / math.sqrt((TP+FP)*(TP+FN)*(TN+FP)*(TN+FN))
print('Matthews Correlation Coefficient :', MCC)



from sklearn.metrics import f1_score
f1_score(y_true, y_pred)

from sklearn.metrics import recall_score
recall_score(y_test, pred)

from sklearn.metrics import matthews_corrcoef
matthews_corrcoef(y_test, pred)

from sklearn.metrics import accuracy_score
accuracy_score(y_test, pred)

import sklearn.metrics as metrics
# calculate the fpr and tpr for all thresholds of the classification

fpr, tpr, threshold = metrics.roc_curve(y_test, pred)
roc_auc = metrics.auc(fpr, tpr)

!pip install matplotlib.pyplot
import matplotlib.pyplot as plt
plt.title('Receiver Operating Characteristic')
plt.plot(fpr, tpr, 'b', label = 'AUC = %0.2f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1],'r--')
plt.xlim([0, 1])
plt.ylim([0, 1])
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()

